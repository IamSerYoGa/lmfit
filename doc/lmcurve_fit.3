.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "lmcurve_fit 3"
.TH lmcurve_fit 3 "2010-04-07" "perl v5.10.1" "lmfit manual"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
lmfit \- C/C++ library for Levenberg\-Marquardt least\-squares minimization and curve fitting
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SS "Generic minimization:"
.IX Subsection "Generic minimization:"
\&\fB#include <lmmin.h\fR>
.PP
\&\fBvoid lmmin( int\fR \fIn_par\fR\fB, double *\fR\fIpar\fR\fB, int\fR \fIm_dat\fR\fB, const\ void *\fR\fIdata\fR\fB,
            void (*\fR\fIevaluate\fR\fB)(...), const\ lm_control_struct *\fR\fIcontrol\fR\fB,
            lm_status_struct *\fR\fIstatus\fR\fB, void (*\fR\fIprintout\fR\fB)(...) );\fR
.PP
The user must supply the following callback routines:
.PP
\&\fBvoid (*\fR\fIevaluate\fR\fB)( const\ double *\fR\fIpar\fR\fB, int\fR \fIm_dat\fR\fB, const\ void *\fR\fIdata\fR\fB,
                  double *\fR\fIfvec\fR\fB, int *\fR\fIinfo\fR\fB );\fR
.PP
\&\fBvoid (*\fR\fIprintout\fR\fB)( int\fR \fIn_par\fR\fB, const\ double *\fR\fIpar\fR\fB, int\fR \fIm_dat\fR\fB,
                  const\ void *\fR\fIdata\fR\fB, const\ double *\fR\fIfvec\fR\fB,
                  int\fR \fIprintflags\fR\fB, int\fR \fIiflag\fR\fB, int\fR \fIiter\fR\fB, int\fR \fInfev\fR\fB );\fR
.PP
For the latter, a default implementation is available:
.PP
\&\fBvoid \fR\fIlm_printout_std\fR\fB(...);\fR
.PP
Control parameters must be given in form of a record
.PP
\&\fBtypedef struct { double\fR \fIftol\fR\fB; double\fR \fIxtol\fR\fB; double\fR \fIgtol\fR\fB;
                 double\fR \fIepsilon\fR\fB; double\fR \fIstepbound\fR\fB; int\fR \fImaxcall\fR\fB;
               } lm_control_struct;\fR
.PP
Default values:
.PP
\&\fBextern const lm_control_struct\fR \fIlm_control_float\fR\fB,\fR \fIlm_control_double\fR\fB;\fR
.PP
Finally, the user must provide a record to receive status information
.PP
\&\fBtypedef struct { double\fR \fIfnorm\fR\fB; int\fR \fInfev\fR\fB; int\fR \fIinfo\fR\fB; } lm_status_struct;\fR
.PP
Status messages, indexed by \fIstatus.info\fR, are supplied in
.PP
\&\fBextern const char *lm_infmsg[];\fR
.SS "Simplified interface for one-dimensional curve fitting:"
.IX Subsection "Simplified interface for one-dimensional curve fitting:"
\&\fB#include <lmcurve.h\fR>
.PP
\&\fBvoid lmcurve_fit( int\fR \fIn_par\fR\fB, double *\fR\fIpar\fR\fB, int\fR \fIm_dat\fR\fB, 
                  const\ double *\fR\fIt\fR\fB, const\ double *\fR\fIy\fR\fB, double (*\fR\fIf\fR\fB)(...),
                  const\ lm_control_struct *\fR\fIcontrol\fR\fB,
                  lm_status_struct *\fR\fIstatus\fR\fB);\fR
.PP
The user must supply the function
.PP
\&\fBdouble\fR \fIf\fR\fB( double\fR \fIt\fR\fB, const\ double *\fR\fIpar\fR\fB );\fR
.SH "NEWS"
.IX Header "NEWS"
.SS "\s-1API\s0 change in version 3.0"
.IX Subsection "API change in version 3.0"
With version 3.0, the application programming interface has changed substantially.
.PP
Generic minimization and one-dimensional curve fitting have been separated more clearly, and the interface for the latter has been greatly simplified (see \fIlmcurve.h\fR and \fIdemo/curve1.c\fR). Furthermore, control (input) and monitoring variables (output) parameters are now stored in two different records. For better readability of the code, even the innermost function declarations of \fIevaluate\fR and \fIprintout\fR have been changed.
.SH "\fBDESCRIPTION\fP"
.IX Header "DESCRIPTION"
.SS "Purpose:"
.IX Subsection "Purpose:"
Determine a parameter vector \fIpar\fR (of dimension \fIn_par\fR) that minimizes the Euclidean norm of a vectorial function \fIfvec\fR(\fIpar\fR) (of dimension \fIm_dat\fR >= \fIn_par\fR).
.PP
The most important application is curve fitting: to approximate data \fIy\fR(\fIt\fR) by a function \fIf\fR(\fIt\fR;\fIpar\fR), minimize the norm of the residual vector \fIfvec\fR = \fIy\fR(\fIt\fR) \- \fIf\fR(\fIt\fR;\fIpar\fR).
.SS "Algorithm:"
.IX Subsection "Algorithm:"
The Levenberg-Marquardt minimization starts with a steepest-descent exploration of the parameter space, and achieves rapid convergence by crossing over into the Newton-Gauss method. For more background, see More\*' 1978, Madsen et al. 2004, and comments in the source code.
.SS "Generic minimization routine:"
.IX Subsection "Generic minimization routine:"
The minimization routine \fBlm_minimize\fR requires the following arguments:
.IP "\fIn_par\fR" 4
.IX Item "n_par"
dimension of parameter vector \fIpar\fR;
.IP "\fIpar\fR" 4
.IX Item "par"
parameter vector. On input, it must contain a reasonable guess; on output, it contains the solution found to minimize ||\fIfvec\fR||;
.IP "\fIm_dat\fR" 4
.IX Item "m_dat"
dimension of residue vector \fIfvec\fR;
.IP "\fIdata\fR" 4
.IX Item "data"
\&\fBlm_minimize\fR does not care about this pointer; it just forwards it to \fIevaluate\fR and \fIprintout\fR;
.IP "\fIevaluate\fR" 4
.IX Item "evaluate"
a routine that calculates the residue vector \fIfvec\fR for given parameter vector \fIpar\fR; setting *\fIinfo\fR to a negative value causes \fBlm_minimize\fR to terminate;
.IP "\fIcontrol\fR" 4
.IX Item "control"
a record holding numeric limits and other auxiliary parameters;
it should always be initialized from provided default records
to ensure upward compatibility;
available default records: \fIlm_control_float\fR, \fIlm_control_double\fR
(for \fIfvec\fR computed to single or double precision, respectively);
.RS 4
.IP "\fBdouble\fR \fIcontrol.ftol\fR" 4
.IX Item "double control.ftol"
relative error desired in the sum of squares;
.IP "\fBdouble\fR \fIcontrol.xtol\fR" 4
.IX Item "double control.xtol"
relative error between last two approximations;
.IP "\fBdouble\fR \fIcontrol.gtol\fR" 4
.IX Item "double control.gtol"
orthogonality desired between fvec and its derivs;
.IP "\fBdouble\fR \fIcontrol.epsilon\fR" 4
.IX Item "double control.epsilon"
step used to calculate the Jacobian;
.IP "\fBdouble\fR \fIcontrol.stepbound\fR" 4
.IX Item "double control.stepbound"
initial bound to steps in the outer loop;
.IP "\fBint\fR \fIcontrol.maxcall\fR" 4
.IX Item "int control.maxcall"
maximum number of iterations;
.IP "\fBint\fR \fIcontrol.printflags\fR" 4
.IX Item "int control.printflags"
\&\s-1OR\s0'ed bits to print (1) status, (2) parameters and norm, (4) residues at end of fit, (8) residues at every step;
.RE
.RS 4
.Sp
\&\fIstatus\fR
.Sp
a record describing the status of the minimization process.
.IP "\fBdouble\fR \fIstatus.fnorm\fR" 4
.IX Item "double status.fnorm"
norm of the residue vector fvec;
.IP "\fBint\fR \fIstatus.nfev\fR" 4
.IX Item "int status.nfev"
actual number of iterations;
.IP "\fBint\fR \fIstatus.info\fR" 4
.IX Item "int status.info"
status of minimization; for explanation print \fIlm_infmsg\fR\fB[\fR\fIstatus.info\fR\fB]\fR;
.RE
.RS 4
.RE
.IP "\fIprintout\fR" 4
.IX Item "printout"
a routine that can be used to inform about the progress of the minimization (\fIiflag\fR: location of call within \fBlm_minimize\fR, \fIiter\fR: outer loop counter, \fInfev\fR: number of calls to \fIevaluate\fR);
if no monitoring is desired, \fBlm_minimize\fR
may be called with \fIprintout\fR or \fIcontrol.printflags\fR set to 0.
.SS "One-dimensional curve fitting:"
.IX Subsection "One-dimensional curve fitting:"
See application sample \fIdemo/curve1.c\fR.
.SS "Fitting a function of a vectorial argument:"
.IX Subsection "Fitting a function of a vectorial argument:"
See application sample \fIdemo/surface1.c\fR.
.SS "Minimize the norm of a vectorial function:"
.IX Subsection "Minimize the norm of a vectorial function:"
Several application samples are provided;
they also serve as test suite to ascertain that the fit algorithm
overcomes well-known numerical problems:
.PP
\&\fIdemo/morobropro.c\fR: \fIm\fR=3, \fIn\fR=2, modified Rosenbrock problem, testing robustness for widely different vectorial components.
.PP
\&\fIdemo/powell.c\fR: \fIm\fR=2, \fIn\fR=2, Powell 1970, with singular Jacobian at the solution par=0.
.PP
\&\fIdemo/hat.c\fR: \fIm\fR=2, \fIn\fR=1, asymetric mexican hat function ||\fIF\fR(\fIp\fR)||. Fit result depends on starting value \- lmfit does not strive to overcome the limitation to local optimisation.
.SH "RESSOURCES"
.IX Header "RESSOURCES"
lmfit is ready for use with C or \*(C+ code. The implementation is self-contained; it does not require external libraries.
.PP
Main web site: http://www.messen\-und\-deuten.de/lmfit/
.PP
Download location: http://www.messen\-und\-deuten.de/lmfit/src/
.PP
Installation with the usual sequence (\fB./configure; make; sudo make install\fR).
After installation, this documentation is available through \fBman lmfit\fR.
.PP
The old download location at sourceforge.net is no longer maintained (too much advertising there, too slow, too complicated)
.SH "FAQ"
.IX Header "FAQ"
.SS "Is it possible to impose constraints on the fit parameters (like p0>=0 or \-10<p1<10) ?"
.IX Subsection "Is it possible to impose constraints on the fit parameters (like p0>=0 or -10<p1<10) ?"
There is no mechanism to impose constraints within the Levenberg-Marquardt algorithm.
.PP
According to my experience, no such mechanism is needed. Constraints can be imposed by variable transform or by adding a penalty to the sum of squares.
Variable transform seems to be the better solution.
In the above examples: use p0^2 and 10*tanh(p1) instead of p0 and p1.
.PP
If you think your problem cannot be handled in such a way, I would be interested to learn why. Please send me one data set (plain \s-1ASCII\s0, two columns, blank separated) along with the fit function and a brief explanation of the application context.
.SS "Is there a way to obtain error estimates for fit parameters ?"
.IX Subsection "Is there a way to obtain error estimates for fit parameters ?"
The problem is only well posed if the covariance matrix of the input data is known. In this case, the error propagation towards the output parameters can be calculated in linear approximation (<http://en.wikipedia.org/wiki/Linear_least_squares>). Note that fit parameters are correlated with each other even if the input covariance matrix is diagonal.
.PP
In linear approximation, the output covariance matrix depends mainly on the Jacobian of the fit function (evaluated for all data points) versus the fit parameters (at their optimum values). It seems not advisable to use the Jacobian \fIfjac\fR that is calculated in the beginning of the main iteration in \fBlm_lmdif(...)\fR, as it is only returned after some transformations.
.PP
I would be glad to include code for the calculation of parameter covariances in this distribution; contributions would be highly welcome.
.SS "How should I cite lmfit in scientific publications ?"
.IX Subsection "How should I cite lmfit in scientific publications ?"
If fit results are robust, it does not matter by which implementation they have been obtained. If the results are not robust, they should not be published anyway. Therefore, in publishing fit results obtained with lmfit it is generally not necessary to cite the software.
.PP
However, in methodological publications that describe software and data analysis procedures based on lmfit, it might be appropriate to provide a reference. The preferred form of citation is:
.PP
Joachim Wuttke: lmfit \- a C/\*(C+ routine for Levenberg-Marquardt minimization with wrapper for least-squares curve fitting, based on work by B. S. Garbow, K. E. Hillstrom, J. J. More\*', and S. Moshier. Version <..>, retrieved on <..> from http://www.messen\-und\-deuten.de/lmfit/.
.SH "REFERENCES"
.IX Header "REFERENCES"
K Levenberg: A method for the solution of certain nonlinear problems in least squares. Quart. Appl. Math. 2, 164\-168 (1944).
.PP
D W Marquardt: An algorithm for least squares estimation of nonlinear parameters. \s-1SIAM\s0 J. Appl. Math. 11, 431\-441 (1963).
.PP
J M More\*': The Levenberg-Marquardt algorithm: Implementation and theory. Lect. Notes Math. 630, 105\-116 (1978).
.PP
K Madsen, H B Nielsen, O Tingleff: Methods for non-linear least squares problems. http://www.imm.dtu.dk/pubdb/views/edoc_download.php/3215/pdf/imm3215.pdf (2004).
.SH "AUTHOR"
.IX Header "AUTHOR"
Joachim Wuttke <j.wuttke@fz\-juelich.de>
.SH "COPYING"
.IX Header "COPYING"
Copyright (C) 2009\-10 Joachim Wuttke.
.PP
Software: Public Domain. If you think this work is worth it, you can
drink a beer in my honor.
.PP
Documentation: Creative Commons Attribution Share Alike.
